name: Version and Tag

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  bump:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Handle Versioning (patch bump)
      id: version
      run: |
        if [ ! -f VERSION ]; then
          echo "1.0.0" > VERSION
        fi
        version=$(cat VERSION)
        IFS='.' read -r major minor patch <<< "$version"
        patch=$((patch + 1))
        new_version="$major.$minor.$patch"
        echo "$new_version" > VERSION
        echo "NEW_VERSION=$new_version" >> $GITHUB_ENV
        echo "Bumped version $version -> $new_version"

    - name: Check for PAT secret
      run: |
        if [ -z "${{ secrets.RELEASE_PAT }}" ]; then
          echo "ERROR: repository secret RELEASE_PAT is not set. Create a personal access token with 'repo' scope and add it as the secret RELEASE_PAT." >&2
          exit 1
        fi

    - name: Commit and push VERSION using PAT and author secrets
      run: |
        if [ -z "${{ secrets.RELEASE_AUTHOR_NAME }}" ] || [ -z "${{ secrets.RELEASE_AUTHOR_EMAIL }}" ]; then
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          author="github-actions[bot] <github-actions[bot]@users.noreply.github.com>"
        else
          git config user.name "${{ secrets.RELEASE_AUTHOR_NAME }}"
          git config user.email "${{ secrets.RELEASE_AUTHOR_EMAIL }}"
          author="${{ secrets.RELEASE_AUTHOR_NAME }} <${{ secrets.RELEASE_AUTHOR_EMAIL }}>"
        fi
        git add VERSION
        git commit --author "$author" -m "Bump version to $NEW_VERSION" || echo "No changes to commit"
        export GIT_COMMITTER_NAME="$(git config user.name)"
        export GIT_COMMITTER_EMAIL="$(git config user.email)"
        git remote set-url origin https://${{ secrets.RELEASE_PAT }}@github.com/${{ github.repository }}.git
        git push origin HEAD:main

    - name: Create annotated Tag and push using PAT
      run: |
        # use the same identity for tagger
        git config user.name "$(git config user.name)"
        git config user.email "$(git config user.email)"
        git tag -a v${{ env.NEW_VERSION }} -m "Release v${{ env.NEW_VERSION }}"
        git remote set-url origin https://${{ secrets.RELEASE_PAT }}@github.com/${{ github.repository }}.git
        git push origin v${{ env.NEW_VERSION }}


    - name: Find Android APK
      id: find_apk
      run: |
        apk=$(ls ./artifacts/android/**/*.apk | head -n1 || true)
        echo "apk=$apk" >> $GITHUB_OUTPUT

    - name: Sign Android APK
      id: sign_android
      env:
        COSIGN_EXPERIMENTAL: 1
      run: |
        if [ "${{ steps.find_apk.outputs.apk }}" != "" ]; then
          ./cosign sign-blob --keyless --yes "${{ steps.find_apk.outputs.apk }}" > "${{ steps.find_apk.outputs.apk }}.sig" || true
          echo "apk_exists=true" >> $GITHUB_OUTPUT
        else
          echo "apk_exists=false" >> $GITHUB_OUTPUT
        fi

    - name: Upload Android APK
      if: steps.sign_android.outputs.apk_exists == 'true'
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: ${{ steps.find_apk.outputs.apk }}
        asset_name: NeoWallet-${{ github.ref_name }}-Android.apk
        asset_content_type: application/vnd.android.package-archive

    - name: Upload Android APK Signature
      if: steps.sign_android.outputs.apk_exists == 'true'
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: ${{ steps.find_apk.outputs.apk }}.sig
        asset_name: NeoWallet-${{ github.ref_name }}-Android.apk.sig
        asset_content_type: application/octet-stream

    - name: Sign macOS ZIP
      id: sign_macos
      env:
        COSIGN_EXPERIMENTAL: 1
      run: |
        if [ -f ./artifacts/macos/NeoWallet-${{ github.ref_name }}-macOS.zip ]; then
          ./cosign sign-blob --keyless --yes ./artifacts/macos/NeoWallet-${{ github.ref_name }}-macOS.zip > ./artifacts/macos/NeoWallet-${{ github.ref_name }}-macOS.zip.sig || true
          echo "exists=true" >> $GITHUB_OUTPUT
        else
          echo "exists=false" >> $GITHUB_OUTPUT
        fi

    - name: Upload macOS asset
      if: steps.sign_macos.outputs.exists == 'true'
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: ./artifacts/macos/NeoWallet-${{ github.ref_name }}-macOS.zip
        asset_name: NeoWallet-${{ github.ref_name }}-macOS.zip
        asset_content_type: application/zip

    - name: Upload macOS signature
      if: steps.sign_macos.outputs.exists == 'true'
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: ./artifacts/macos/NeoWallet-${{ github.ref_name }}-macOS.zip.sig
        asset_name: NeoWallet-${{ github.ref_name }}-macOS.zip.sig
        asset_content_type: application/octet-stream